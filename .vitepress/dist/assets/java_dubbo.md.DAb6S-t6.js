import{_ as n,c as s,o as a,a1 as p}from"./chunks/framework.C46D9NsM.js";const v=JSON.parse('{"title":"dubbo","description":"","frontmatter":{},"headers":[],"relativePath":"java/dubbo.md","filePath":"java/dubbo.md"}'),e={name:"java/dubbo.md"},l=p(`<h1 id="dubbo" tabindex="-1">dubbo <a class="header-anchor" href="#dubbo" aria-label="Permalink to &quot;dubbo&quot;">​</a></h1><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/tasks/develop/template/" target="_blank" rel="noreferrer">https://cn.dubbo.apache.org/zh-cn/overview/tasks/develop/template/</a></li><li><a href="https://github.com/apache/dubbo-admin/releases" target="_blank" rel="noreferrer">https://github.com/apache/dubbo-admin/releases</a> dubbo-admin</li></ul><h2 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h2><ul><li>dubbo3 + springboot3 + Nacos + protobuf 实现生产者</li><li><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/tasks/develop/idl/" target="_blank" rel="noreferrer">https://cn.dubbo.apache.org/zh-cn/overview/tasks/develop/idl/</a></li></ul></li><li>go + gRPC实现消费者</li><li>dubbo-admin针对以上服务进行检测</li><li>流量管控</li><li>限流降级</li><li>HTTP网关</li><li><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/tasks/ecosystem/gateway/" target="_blank" rel="noreferrer">https://cn.dubbo.apache.org/zh-cn/overview/tasks/ecosystem/gateway/</a></li></ul></li><li>配置中心</li><li><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/" target="_blank" rel="noreferrer">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/</a></li></ul></li><li>k8s部署</li></ul><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RPC</span></span>
<span class="line"><span>    Remote procedure call</span></span>
<span class="line"><span>RPC协议</span></span>
<span class="line"><span>    内容</span></span>
<span class="line"><span>    格式</span></span>
<span class="line"><span>    控制数据</span></span>
<span class="line"><span>        序列化方式</span></span>
<span class="line"><span>        超时时间</span></span>
<span class="line"><span>        压缩方式</span></span>
<span class="line"><span>        鉴权信息</span></span>
<span class="line"><span>    Dubbo2</span></span>
<span class="line"><span>    http/1.1</span></span>
<span class="line"><span>        head-of-line问题</span></span>
<span class="line"><span>        性能差</span></span>
<span class="line"><span>        无直接server push支持</span></span>
<span class="line"><span>    gRPC</span></span>
<span class="line"><span>        http2</span></span>
<span class="line"><span>            server push</span></span>
<span class="line"><span>            多路复用</span></span>
<span class="line"><span>            流量控制</span></span>
<span class="line"><span>        protobuf</span></span>
<span class="line"><span>            +跨平台二进制</span></span>
<span class="line"><span>            +k8s/etcd天然支持协议，云原生的事实协议标准</span></span>
<span class="line"><span>            -对服务治理的支持比较基础  (服务治理？？)</span></span>
<span class="line"><span>            -强绑定protobuf的序列化方式，较高的学习和改造成本</span></span>
<span class="line"><span>    thrift</span></span>
<span class="line"><span>        facebook</span></span>
<span class="line"><span>    Triple(Dubbo3)</span></span>
<span class="line"><span>        +兼容gRPC</span></span>
<span class="line"><span>        +metadata和payload分离，避免中间设备对payload进行解析和反序列化（分离就不反序列化了？）</span></span>
<span class="line"><span>        +支持自定义header</span></span>
<span class="line"><span>        +支持mTLS</span></span>
<span class="line"><span>        +除了支持protobuf方式，还支持Hessian/json等其他序列化</span></span>
<span class="line"><span>        +易用，一行配置搞定。</span></span>
<span class="line"><span>        +Streaming RPC,长连接,TCP上支持多个Stream</span></span>
<span class="line"><span>服务治理控制面</span></span>
<span class="line"><span>    注册中心</span></span>
<span class="line"><span>    流量管控策略</span></span>
<span class="line"><span>    Dubbo Admin 控制台</span></span>
<span class="line"><span>        https://github.com/apache/dubbo-admin/releases</span></span>
<span class="line"><span>    如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面</span></span>
<span class="line"><span>Dubbo 数据面</span></span>
<span class="line"><span>服务治理(在微服务集群环境下)</span></span>
<span class="line"><span>    无状态服务节点动态变化</span></span>
<span class="line"><span>    外部化配置</span></span>
<span class="line"><span>    日志跟踪</span></span>
<span class="line"><span>    可观测性</span></span>
<span class="line"><span>    流量管理</span></span>
<span class="line"><span>    高可用性</span></span>
<span class="line"><span>    数据一致性</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>微服务架构</span></span>
<span class="line"><span>    Service Mesh</span></span>
<span class="line"><span>        Istio是其开源代表实现</span></span>
<span class="line"><span>    spring cloud</span></span>
<span class="line"><span>        +更易上手</span></span>
<span class="line"><span>        +spring更多的原生支持</span></span>
<span class="line"><span>        +服务发现、动态配置、异步消息、批处理任务、定时任务、持久化数据。。。</span></span>
<span class="line"><span>        -只提供抽象模式的定义不提供官方稳定实现</span></span>
<span class="line"><span>        -欠缺服务治理能力,流量管控方面如负载均衡、流量路由方面能力都比较弱</span></span>
<span class="line"><span>        -HTTP</span></span>
<span class="line"><span>        -很多微服务实践场景的问题需要用户独自解决，比如</span></span>
<span class="line"><span>            优雅停机、启动预热、服务测试，再比如双注册、双订阅、延迟注册、服务按分组隔离、集群容错</span></span>
<span class="line"><span></span></span>
<span class="line"><span>开发</span></span>
<span class="line"><span>    接口+分组+版本号才能唯一确定一个服务。</span></span>
<span class="line"><span>    RpcContext</span></span>
<span class="line"><span>        ServiceContext</span></span>
<span class="line"><span>            在 Dubbo 内部使用，用于传递调用链路上的参数信息，如 invoker 对象等</span></span>
<span class="line"><span>        ClientAttachment</span></span>
<span class="line"><span>            Client 端，ClientAttachment将传递到server端</span></span>
<span class="line"><span>        ServerAttachment</span></span>
<span class="line"><span>            Server 端,ServerAttachment读取client传的参数</span></span>
<span class="line"><span>                RpcContext.getServerContext().setAttachment(&quot;serverKey&quot;,&quot;serverValue&quot;);</span></span>
<span class="line"><span>        ServerContext</span></span>
<span class="line"><span>            Server 端回传 Client 端使用</span></span>
<span class="line"><span>                    Map&lt;String, Object&gt; clientAttachment = RpcContext.getServerContext().getObjectAttachments();</span></span></code></pre></div>`,6),i=[l];function t(c,r,o,b,h,d){return a(),s("div",null,i)}const m=n(e,[["render",t]]);export{v as __pageData,m as default};
